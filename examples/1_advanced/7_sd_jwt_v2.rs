// Copyright 2020-2026 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

//! This example shows how to create a selective disclosure verifiable credential - that uses data model v2.0 -
//! according to the [JOSE/COSE standard](https://www.w3.org/TR/vc-jose-cose/#securing-with-sd-jwt) and validate it.
//!
//! cargo run --release --example sd_jwt_v2

use examples::create_did_document;
use examples::get_funded_client;
use examples::get_memstorage;
use identity_eddsa_verifier::EdDSAJwsVerifier;
use identity_iota::core::json;
use identity_iota::core::FromJson;
use identity_iota::core::Object;
use identity_iota::core::Timestamp;
use identity_iota::core::ToJson;
use identity_iota::core::Url;
use identity_iota::credential::CredentialBuilder;
use identity_iota::credential::CredentialV2;
use identity_iota::credential::JwtCredentialValidationOptions;
use identity_iota::credential::KeyBindingJwtValidationOptions;
use identity_iota::credential::SdJwtCredentialValidator;
use identity_iota::credential::Subject;
use identity_iota::did::DID;
use identity_storage::StorageSigner;
use sd_jwt::KeyBindingJwtBuilder;
use sd_jwt::RequiredKeyBinding;
use sd_jwt::SdJwtBuilder;
use sd_jwt::Sha256Hasher;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
  // ===========================================================================
  // Step 1: Create identities for the issuer and the holder.
  // ===========================================================================

  // Create an identity for the issuer with one verification method `key-1`.
  let issuer_storage = get_memstorage()?;
  let issuer_identity_client = get_funded_client(&issuer_storage).await?;
  let (issuer_document, issuer_vm_fragment) = create_did_document(&issuer_identity_client, &issuer_storage).await?;

  // Create an identity for the holder, in this case also the subject.
  let holder_storage = get_memstorage()?;
  let holder_identity_client = get_funded_client(&holder_storage).await?;
  let (holder_document, holder_vm_fragment) = create_did_document(&holder_identity_client, &holder_storage).await?;

  // ===========================================================================
  // Step 2: Issuer creates and signs a selectively disclosable JWT verifiable credential.
  // ===========================================================================

  // Create an address credential subject.
  let subject: Subject = Subject::from_json_value(json!({
    "id": holder_document.id().as_str(),
    "name": "Alice",
    "address": {
      "locality": "Maxstadt",
      "postal_code": "12344",
      "country": "DE",
      "street_address": "Weidenstra√üe 22"
    }
  }))?;

  // Build credential using subject above and issuer.
  let credential: CredentialV2 = CredentialBuilder::default()
    .id(Url::parse("https://example.com/credentials/3732")?)
    .issuer(Url::parse(issuer_document.id().as_str())?)
    .type_("AddressCredential")
    .subject(subject)
    .build_v2()?;

  println!("Plaintext Credential:\n{}", credential.to_json_pretty()?);

  // Encode the credential as an SD-JWT.
  // The issuer decides to make the subject address's "locality", "postal_code",
  // and "street_address" properties selectively disclosable.
  // The issuer also requires a Key Binding JWT signed by the holder's key to be
  // presented along with the SD-JWT.
  let issuer_signer =
    StorageSigner::new_from_vm_fragment(&issuer_storage, &issuer_document, &issuer_vm_fragment).await?;
  let sd_jwt_credential = SdJwtBuilder::new(credential)?
    // Narrow the type to VC SD-JWT as per the spec.
    .header("typ", "vc+sd-jwt")
    // Set the issuer's verification method as the `kid` so that the verifiers can identify the correct key.
    .header("kid", format!("{}#{}", issuer_document.id(), issuer_vm_fragment))
    .make_concealable("/credentialSubject/address/locality")?
    .make_concealable("/credentialSubject/address/postal_code")?
    .make_concealable("/credentialSubject/address/street_address")?
    .require_key_binding(RequiredKeyBinding::Kid(format!(
      "{}#{}",
      holder_document.id(),
      holder_vm_fragment
    )))
    .finish(&issuer_signer, "EdDSA")
    .await?;

  // ===========================================================================
  // Step 3: Issuer sends the JWT and the disclosures to the holder.
  // ===========================================================================

  println!("SD-JWT Credential:\n{sd_jwt_credential}");

  // ===========================================================================
  // Step 4: Verifier sends the holder a challenge and requests a signed Verifiable Presentation.
  // ===========================================================================

  const VERIFIER_DID: &str = "did:example:verifier";
  // A unique random challenge generated by the requester per presentation can mitigate replay attacks.
  let nonce: &str = "475a7984-1bb5-4c4c-a56f-822bccd46440";

  // ===========================================================================
  // Step 5: Holder presents its SD-JWT token to the verifier.
  // ===========================================================================

  let holder_signer =
    StorageSigner::new_from_vm_fragment(&holder_storage, &holder_document, &holder_vm_fragment).await?;
  // The holder only wants to present "locality" and "postal_code" but not "street_address".
  let (mut sd_jwt, _concealed_claims) = sd_jwt_credential
    .into_presentation(&Sha256Hasher)?
    .conceal("/credentialSubject/address/street_address")?
    .finish();

  // The holder creates a Key Binding JWT and attaches it to the SD-JWT.
  let kb_jwt = KeyBindingJwtBuilder::new()
    .aud(VERIFIER_DID)
    .nonce(nonce)
    .iat(Timestamp::now_utc().to_unix())
    .finish(&sd_jwt, &Sha256Hasher, "EdDSA", &holder_signer)
    .await?;
  sd_jwt.attach_key_binding_jwt(kb_jwt);

  println!("SD-JWT Presentation:\n{sd_jwt}");

  // ===========================================================================
  // Step 6: Verifier receives the SD-JWT and verifies it.
  // ===========================================================================

  // Verify the SD-JWT Credential.
  let sd_jwt_validator = SdJwtCredentialValidator::new(EdDSAJwsVerifier::default(), Sha256Hasher);
  let credential = sd_jwt_validator.validate_credential_v2::<_, Object>(
    &sd_jwt,
    std::slice::from_ref(&issuer_document),
    &JwtCredentialValidationOptions::default(),
  )?;

  // Verify the Key Binding JWT.
  sd_jwt_validator.validate_key_binding_jwt(
    &sd_jwt,
    &holder_document,
    &KeyBindingJwtValidationOptions::default().nonce(nonce).aud(VERIFIER_DID),
  )?;

  println!("Valid Credential: \n{}", credential.to_json_pretty()?);

  Ok(())
}
